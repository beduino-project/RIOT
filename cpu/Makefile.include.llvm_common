# Clang on Linux uses GCC's C++ headers and libstdc++ (installed with GCC)
# Ubuntu and Debian use /etc/alternatives/gcc-$(TARGET_ARCH)-include/c++/$(GCC_VERSION)
# Arch uses /usr/$(TARGET_ARCH)/include/c++/$(GCC_VERSION)
# Gentoo uses /usr/lib/gcc/$(TARGET_ARCH)/$(GCC_VERSION)/include/g++-v5
GCC_CXX_INCLUDE_PATTERNS ?= \
  /etc/alternatives/gcc-$(TARGET_ARCH)-include/c++/*/ \
  /usr/$(TARGET_ARCH)/include/c++/*/ \
  /usr/lib/gcc/$(TARGET_ARCH)/*/include/g++-v5 \
  #

# Try to find the proper multilib directory using GCC, this may fail if a cross-
# GCC is not installed.
ifeq ($(GCC_MULTI_DIR),)
  GCC_MULTI_DIR := $(shell $(PREFIX)gcc -print-multi-directory $(CFLAGS) 2>/dev/null)
endif

# Use the wildcard Makefile function to search for existing directories matching
# the patterns above. We use the -isystem gcc/clang argument to add the include
# directories as system include directories, which means they will not be
# searched until after all the project specific include directories (-I/path)
# We sort the list of found directories and take the last one, it will likely be
# the most recent GCC version. This avoids using old headers left over from
# previous tool chain installations.
GCC_CXX_INCLUDES ?= \
    $(addprefix \
        -isystem $(lastword $(sort \
            $(foreach pat, $(GCC_CXX_INCLUDE_PATTERNS), $(wildcard $(pat))))), \
        /. /$(TARGET_ARCH)/$(GCC_MULTI_DIR) /backward \
    )

# If nothing was found we will try to fall back to searching for a cross-gcc in
# the current PATH and use a relative path for the includes
ifeq (,$(GCC_CXX_INCLUDES))
  GCC_CXX_INCLUDES := $(addprefix -isystem ,$(wildcard $(dir $(shell which $(PREFIX)gcc))../$(TARGET_TRIPLE)/include))
endif

# Pass the includes to the C++ compilation rule in Makefile.base
export CXXINCLUDES += $(GCC_CXX_INCLUDES)

# Some C headers (e.g. limits.h) are located with the GCC libraries
GCC_C_INCLUDE_PATTERNS ?= \
  /usr/lib/gcc/$(TARGET_TRIPLE)/*/ \
  #

GCC_C_INCLUDES ?= \
    $(addprefix -isystem ,$(wildcard $(addprefix \
        $(lastword $(sort \
            $(foreach pat, $(GCC_C_INCLUDE_PATTERNS), $(wildcard $(pat))))), \
        include include-fixed) \
    ))

# If nothing was found we will try to fall back to searching for the libgcc used
# by an installed cross-GCC and use its headers.
ifeq (,$(GCC_C_INCLUDES))
  GCC_C_INCLUDES := $(addprefix -isystem ,$(wildcard $(addprefix $(dir $(shell $(PREFIX)gcc -print-libgcc-file-name)), include include-fixed)))
endif
